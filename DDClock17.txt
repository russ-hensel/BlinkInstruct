// Program description ( ):
//      DD clock for arduino using accel library 
//
//      Features
//           moving from experimenting to a production clock more compound commands 
//
// History/Status:  ( most recent at top ** done !! pending )
//        Summary:  Ver5   add a tweak to the stepper position and enhance/refine the chimes
//          
//
// Author:      russ_hensel http://www.opencircuits.com/User:Russ_hensel
//    uses library at:            
//      http://www.airspayce.com/mikem/arduino/AccelStepper/index.html
// ============================= use .h files for easy modification using #define 's ================================

#include "DDClock17.h"        // #defines for this project
#include "SerialCmd.h"        // #defines for command interperter 

// ============================= globals variables ... ========

SerialCmd    serialCmd;
#include <AccelStepper.h>

// for Hours
AccelStepper   stepper1( STEPPER_DRIVE_TYPE, STEPPER1_PIN_A, STEPPER1_PIN_B, STEPPER1_PIN_C, STEPPER1_PIN_D, true ); 

// for Minutes
AccelStepper   stepper2( STEPPER_DRIVE_TYPE, STEPPER2_PIN_A, STEPPER2_PIN_B, STEPPER2_PIN_C, STEPPER2_PIN_D, true ); 

long         cmd_args[20];           // for decoding serial commands 
int          cmd_args_max  = -1;     // index for above 

// consider this but wait
long   hr_fst_acc     = HR_FST_ACC;
long   hr_fst_speed   = HR_FST_SPEED;

// for fine tune of position should be under 20 or so
int   tweak_hr     = 0;
int   tweak_min    = 0;


// ----------------------------------------------------------------
// help just a little intro for the program -- summary of commands and version 
void rptHelp( void ) {  
    Serial.println( F( "" ) );
    Serial.print(   F( "Arduino:  " ) );  
    Serial.println( VERSION_ID  );   

    Serial.println( F( "args for next are hr/min, then others" ) );                    //  eMin  
    Serial.println( F( "n     nudge" ) );                    // case 'n':  void nudge  nudgeHr  nudgeMin  
    Serial.println( F( "t     tweak " ) );                   // case 't':  tweak    tweakHr  tweak Min  
    // Serial.println( F( "args for next are hr/min, steps" ) );                    //  
    Serial.println( F( "c     chime " ) );                   // case 'c'    void chime   void chimeHr void chimeMin     
    Serial.println( F( "d     dance hr/min speed acc steps" ) );                    // case 'd'   void danceStep   void doHrDance  doMinDance     ( hr/min int arg_delay, float arg_speed, float arg_acc, long delta_step  )   
    //Serial.println( F( "--- old standards  --- " ) ); 
    Serial.println( F( "w     statusReport" ) );          //  case 'w':       status    need rewrite update 
    Serial.println( F( "v     Version of software" ) );   //  rptVersion
    Serial.println( F( "?     Help" ) );                  //   rptHelp
}

// ---------- Main ----------   
void loop()   {
    
    unsigned char   debugStr;
    unsigned char   locCmd;
    //long            cmdPriorNbr;
    uint8_t         z_pin;    // pin for z command 
    
    serialCmd.tryRecCmd( );
    
    // stopFlag not used now just old junk 
    if ( serialCmd.stopFlag  )   {
      //Serial.print( F( "# Stopped" ) );
      //Serial.println( "" );
      serialCmd.stopFlag  = 0;
      serialCmd.gotCmd    = 0;
    }
    if ( serialCmd.gotCmd  )   {
//      Serial.print( "cmd = "  );
//      Serial.print( serialCmd.cmdPrior );
//      Serial.print( "\r" );
      getArgs( );                           // get args in the global array
      locCmd   = serialCmd.cmdPrior[0];     // in case access is expensive
      // lower case the command as necessary // combine with above and make sub, possibly inline -- beware special char 
      if ( ( locCmd < 97 ) && ( locCmd > 64 ) ) {
          locCmd += 32;
      } 
       // cmdPriorNbr   = serialCmd.parseCmdNbr( serialCmd.cmdPrior );
      // decode command....
      switch ( locCmd )  {
     
         case 'c':  //   a chime number and time 
            chime( );     // void chimeHr  void chimeMin  (  chime11  ;    //   motor position speed acceleration  
            break;
        case 'd':  //     
            danceStep();     
            break;                  
        case 'n':  //     
            nudge();     // void nudge
            break; 
        case 't':  //     
            tweak();     
            break;                                          
         case 'v':  // report version 
            rptVersion();
            break; 
         case 'w':  // report version 
            statusReport( );
            break;                 
         case '?':  // report help
            rptHelp();
            break;                                     
        default:
          Serial.print( F( "!Bad Command = " ) );
          Serial.println( serialCmd.cmdPrior );
        } 
        Serial.println( F( "ok"  ) );
        serialCmd.gotCmd    = 0;
    }           
}

// ---------------------------------------------- 
// 
void tweak(   ) {
       if ( cmd_args[ 0 ] == HR_IX )  {
               tweakHr( cmd_args[ 1 ]  );
       }  else {
               tweakMin( cmd_args[ 1 ] );
       }
}

// ---------------------------------------------- 
// ** tweaked 
void tweakHr( int arg_steps  ) {
      long  current_pos;
      
      current_pos   =  getPosHr( );
      tweak_hr      += arg_steps;
      goToHrStep( current_pos, HR_STD_SPEED, HR_STD_ACC   );
      wiggleHr( WIGGLE_STEPS );
      Serial.print( F( "Hr tweak: ") ); 
      Serial.println(  tweak_hr ); 
}

// ---------------------------------------------- 
// this need not be at 0 to work, but try it there first for testing 
void tweakMin( int arg_steps  ) {
      long  current_pos;
      
      current_pos   =  getPosMin( );
      tweak_min     += arg_steps;
      goToMinStep( current_pos, HR_STD_SPEED, HR_STD_ACC   );
      wiggleMin( WIGGLE_STEPS );
      Serial.print( F( "Min tweak: ") ); 
      Serial.println(  tweak_min ); 
}

// ---------------------------------------------- 
// 
void nudge(   ) {
       if ( cmd_args[ 0 ] == HR_IX )  {
               nudgeHr( cmd_args[ 1 ]  );
       }  else {
               nudgeMin( cmd_args[ 1 ] );
       }
}

// ---------------------------------------------- 
// 
void nudgeHr( int arg_steps  ) {
  
      Serial.print( "nudgeHr " );
      Serial.println( arg_steps );
      goToHrStep( getPosHr( ) + arg_steps , HR_STD_SPEED, HR_STD_ACC   );    // 
      zeroHr(); // or set to offset or a new set to 0 ???
      goToHrStep( 0 , HR_STD_SPEED, HR_STD_ACC   ); 
      wiggleHr( WIGGLE_STEPS );   
}

// ---------------------------------------------- 
//   ** think ok for tweak moves a bit and sets to 0 
// assuming you start from 0 this nudges the 0 position -- or starting from any where? now starting from any where but leave at 0 
// best used a 0 
void nudgeMin( int arg_steps  ) {
      Serial.print( "nudge " );
      Serial.println( arg_steps );
      // goToMinStep( STEPPER_MIN.currentPosition() + arg_steps,     HR_STD_SPEED, HR_STD_ACC   );
      goToMinStep( getPosMin( ) + arg_steps , HR_STD_SPEED, HR_STD_ACC   );    //+ arg_steps //+ arg_steps
      //current_step   =  getPosMin( );
      zeroMin(); // or set to offset or a new set to 0 ???
      goToMinStep( 0 , HR_STD_SPEED, HR_STD_ACC   ); 
      wiggleMin( WIGGLE_STEPS );
}

// ---------------------------------------------- 
// 
void wiggleHr( int arg_steps  ) {
      long current_step;

      current_step   =  getPosHr( );
      goToHrStep( current_step + arg_steps, HR_STD_SPEED, HR_STD_ACC   );
      goToHrStep( current_step,             HR_STD_SPEED, HR_STD_ACC   );
}

// ---------------------------------------------- 
// ** tweak ok once go to minut step ok 
void wiggleMin( int arg_steps  ) {
      long current_step;
 
      current_step   =  getPosMin( );
      goToMinStep( current_step + arg_steps, MIN_STD_SPEED, HR_STD_ACC   );
      goToMinStep( current_step,             MIN_STD_SPEED, HR_STD_ACC   );
}

// ----------------------------------------------
// type and time   
void chime(   ) {
      if ( cmd_args[ 0 ] == HR_IX ){     
            chimeHr( );     // chimeHr(  chime11  ;    //   motor position speed acceleration  
      }
      else {
            chimeMin();    
      }
}

// ----------------------------------------------
// type and time   
void chimeHr(   ) {
      long target_step;
      long target_hr;
     
      target_hr      = cmd_args[ 2 ];
      target_step    = 2 *  hr_to_steps[ target_hr ];   //   convert to steps

      Serial.print(   "chime hr arg1 = " ); 
      Serial.println( cmd_args[ 1 ] );          
      Serial.print(   "target_hr = " );
      Serial.println( target_hr    );
      Serial.print(   "chime target_step = " );
      Serial.println( target_step    );
      switch ( cmd_args[ 1 ] )  {
        case 0:  // 
            chimeHr00( target_step );
            break;    
        case 1:  // 
            chimeHr01( target_step );
            break;
        case 2:  // 
            chimeHr02( target_step );
            break;
        case 3:  // 
            chimeHr03( target_step );
            break;
       case 4:  // 
            chimeHr04( target_step );
            break;
        case 5:  // 
            chimeHr00( target_step );  // out for testing
            break;
        case 6:  // 
            chimeHr06( target_step );
            break;
        case 7:  // 
            chimeHr07( target_step );
            break;
        case 8:  // 
            chimeHr08( target_step );
            break;
        case 19:  // 
            chimeHr00( target_step );
            break;
        default:
          Serial.print( F( "!what chime = " ) );
          Serial.println( cmd_args[ 0 ] );
        } 
    Serial.print(    F("all done Hr pos = " ) );
    Serial.println(  STEPPER_HR.currentPosition() );        // !! change for tweaked 
//        Serial.println( cmd_args[ 1 ] );
//        Serial.println( cmd_args[ 2 ] );
//        Serial.println( cmd_args[ 3 ] );
}

// ----------------------------------------------
// no dance just go there ( shortest way? ) 
void chimeHr00( long target_step  ) {

    goToHrStep( target_step, HR_STD_SPEED, HR_STD_ACC   );
}

// ----------------------------------------------
// spin long, then reverse to target 
void chimeHr01( long target_step  ) {
    long     curent_step;
    long     delta_step;
    
    curent_step    =  getPosHr( );
    delta_step     =  target_step - curent_step;
    Serial.print(   "delta_step " );
    Serial.println( delta_step    );
    // statusReport( );
    Serial.print(   "start " );
    Serial.println(  curent_step );
    // int arg_delay, float arg_speed, float arg_acc, long arg_step 
    doHrDanceStep( 0,    500.,         10000, 2000        );
    Serial.print(   "done 1 " );
    Serial.println(  getPosHr( ) );
    doHrDanceStep( 0,    500.,         10000, -2000       );
    Serial.print(   "done 2 " );
    Serial.println(  getPosHr( ) );
    
    doHrDanceStep( 0,    100,          100,   delta_step );
    Serial.print(   "all done " );
    Serial.println(  getPosHr( ) );
}

// ----------------------------------------------
// one long spin to the target 
void chimeHr02( long target_step  ) {
    long     curent_step;
    long     delta_step;
    curent_step    =  getPosHr( );
    delta_step     =  target_step - curent_step;
    Serial.print(   "delta_step " );
    Serial.println( delta_step    );

    Serial.print(   "start " );
    Serial.println(  getPosHr( ) );
    // int arg_delay, float arg_speed, float arg_acc, long arg_step 
    doHrDanceStep( 0,    500.,         10000, 4000 +  delta_step       );

    Serial.print(   "all most done " );
    Serial.println(  getPosHr( ) );
    setPosHr( target_step );
}

// ----------------------------------------------
void chimeHr03( long target_step  ) {  //  vibrate increasing for beginning of chime 
    //long     curent_step;
    //long     delta_step;
    
    // vibrate_hr_up( long delta_step, long max_step, long speed, long acc   ) {
    vibrate_hr_up( 5, 50,    HR_STD_SPEED, HR_STD_ACC   );
    goToHrStep( target_step, HR_STD_SPEED, HR_STD_ACC   );
}

// ----------------------------------------------
void chimeHr04( long target_step  ) { // one long spin to the target then vibrate around it -- using vibrate  
    long     curent_step;
    long     delta_step;
    
    curent_step    =  getPosHr( );
    delta_step     =  target_step - curent_step;
    //Serial.print(   "delta_step " );
    //Serial.println( delta_step    );

    //Serial.print(   "start " );
    //Serial.println(  getPosHr( ) );
    // int arg_delay, float arg_speed, float arg_acc, long arg_step 
    doHrDanceStep( 0,    500.,         10000, 4000 +  delta_step       );
    setPosHr( target_step );    // renormalize turns/steps
    
    // vibrate( long initial_step, long delta_step, long speed, bool do_initial_step  )
    vibrate_hr( 50, 2, HR_FST_SPEED, true  );
}

// ----------------------------------------------
void chimeHr05( long target_step  ) { // stagger from 100 does not look finished -- stagger part works target missed 
    long     curent_step;
    long     delta_step;
    
    curent_step    =  getPosHr( );
    delta_step     =  target_step - curent_step + 100;    // miss by 100 for stager 
    // int arg_delay, float arg_speed, float arg_acc, long arg_step 
    doHrDanceStep( 0,    500.,         10000, 200 + delta_step       );
    doHrDanceStep( 0,    500.,         10000, -200         );
    Serial.print(   "delta_step " );
    Serial.println( delta_step    );
    // need to get on target or 100 from target 
    
    hr_stager_from_100( 1 );
}

// ----------------------------------------------
void chimeHr06( long target_step  ) { // back and forth 180 degrees perperdeniclar to the correct time 
    //long     curent_step;
    //long     delta_step;

    long     perp_step;  // perpendicular to target 

    perp_step      =  target_step + 100;
    if ( perp_step   > 400 ){   // maybe modulo better??
      perp_step    = perp_step - 400;
    }
    goToHrStep( perp_step, HR_STD_SPEED, HR_STD_ACC   );
    // doHrDanceStep(( int arg_delay, float arg_speed, float arg_acc, long delta_step  )
    doHrDanceStep( 0,       HR_STD_SPEED,        HR_STD_ACC, -200     );
    doHrDanceStep( 0,       HR_STD_SPEED,        HR_STD_ACC, 200     );
    doHrDanceStep( 0,       HR_STD_SPEED,        HR_STD_ACC, -200     );
    doHrDanceStep( 0,       HR_STD_SPEED,        HR_STD_ACC, 200     );
    doHrDanceStep( 0,       HR_STD_SPEED,        HR_STD_ACC, -200     );
    doHrDanceStep( 0,       HR_STD_SPEED,        HR_STD_ACC, 200     );
    doHrDanceStep( 0,       HR_FST_SPEED,        HR_STD_ACC, -200     );
    doHrDanceStep( 0,       HR_FST_SPEED,        HR_STD_ACC, 200     );
    goToHrStep( target_step, HR_STD_SPEED, HR_STD_ACC   );
    
}

// ----------------------------------------------
void chimeHr07( long target_step  ) { // back and forth 180 degrees perperdeniclar to the correct time wiggle 

    long     perp_step;  // perpendicular to target 

    perp_step      =  target_step + 100;
    if ( perp_step   > 400 ){   // maybe modulo better??
      perp_step    = perp_step - 400;
    }
    goToHrStep( perp_step, HR_STD_SPEED, HR_STD_ACC   );
    // doHrDanceStep(( int arg_delay, float arg_speed, float arg_acc, long delta_step  )
    wiggleHr( 25 );  // or do with a few dance steps 
    wiggleHr( 25 );  // or do with a few dance steps 
    wiggleHr( 25 );  // or do with a few dance steps 
    doHrDanceStep( 0,       HR_STD_SPEED,       HR_STD_ACC, -200     );
    wiggleHr( 25 );  // or do with a few dance steps 
    wiggleHr( 25 );  // or do with a few dance steps 
    wiggleHr( 25 );  // or do with a few dance steps 
    doHrDanceStep( 0,    HR_STD_SPEED,        HR_STD_ACC, 200     );
    wiggleHr( 25 );  // or do with a few dance steps 
    wiggleHr( 25 );  // or do with a few dance steps 
    wiggleHr( 25 );  // or do with a few dance steps 
    goToHrStep( target_step, HR_STD_SPEED, HR_STD_ACC   );
}
  
// ---------------------------------------------- 
void chimeHr08( long target_step  ) { // back and forth 180 degrees perperdeniclar to the correct time wiggle  could add  a twirl prior to each 

    //long     perp_step;  // perpendicular to target 
    long     i_step;  // 
//    perp_step      =  target_step + 100;   // ?? make a perp function, make an wind unwind 
//    if ( perp_step   > 400 ){   // maybe modulo better??
//      perp_step    = perp_step - 400;
//    }

    for ( int ix  = 1;   ix <= 12;  ix ++ ) { 
         i_step    = 2 *  hr_to_steps[ ix ];   //   convert to steps -- change array to get rid of this !!
         goToHrStep( i_step, HR_STD_SPEED, HR_STD_ACC   );
         delay( 200 );
    }
    goToHrStep( target_step, HR_STD_SPEED, HR_STD_ACC   );
    
}
// ----------------------------------------------
// ** tweak ok 
// type and time  
// call in cmd_args  
void chimeMin(   ) {
      long target_step;
      long target_min;
     
      target_min     = cmd_args[ 2 ];          // eliminate variable ??
      target_step    = ( target_min *10 )/3;   // convert minutes to steps
      Serial.print(   "chime Min " ); 
//      Serial.println( cmd_args[ 1 ] );          
//      Serial.print(   "target_min " );
      Serial.println( target_min    );
//      Serial.print(   "target_step " );
//      Serial.println( target_step    );
      switch ( cmd_args[ 1 ] )  {
        case 0:  // 
            chimeMin00( target_step );
            break;    
        case 1:  // 
            chimeMin01( target_step );
            break;
        case 2:  // 
            chimeMin02( target_step );
            break; 
        case 3:  // 
            chimeMin03( target_step );
            break;   
        case 4:  // 
            chimeMin03( target_step );  // !! for exp
            break;          
        default:
          chimeMin00( target_step );
          Serial.print( F( "!what minChime = " ) );
          Serial.println( cmd_args[ 0 ] );
        } 
}

// ---------------------------------------------- 
// ** tweak ok 
void chimeMin00( long target_step  ) { // no dance just go there ( shortest way? )
    
    goToMinStep( target_step, MIN_STD_SPEED, MIN_STD_ACC   );    
}

// ----------------------------------------------
// wiggle then go  or go then wiggle -- read it 
void chimeMin01( long target_step  ) {

    goToMinStep( target_step, MIN_STD_SPEED, MIN_STD_ACC   );
    wiggleMin( 24  );
    wiggleMin( 24  );
    wiggleMin( 12  );
    wiggleMin( 12  );
}

// ----------------------------------------------
void chimeMin02( long target_step  ) { //jump back then to time 
   // int arg_delay, float arg_speed, float arg_acc, long arg_step 
    doMinDanceStep( 0,        MIN_STD_SPEED,         MIN_STD_ACC, -20 );   
    goToMinStep( target_step, MIN_STD_SPEED,         MIN_STD_ACC     );
}

// ----------------------------------------------
void chimeMin03( long target_step  ) { //jump back to 0 then to time  
   // int arg_delay, float arg_speed, float arg_acc, long arg_step 
    goToMinStep( 0,           MIN_STD_SPEED,         MIN_STD_ACC     );   
    goToMinStep( target_step, MIN_STD_SPEED,         MIN_STD_ACC     );
}

// ----------------------------------------------
// vibrate hand, in decreasing amounts  
void vibrate_hr( long initial_step, long delta_step, long speed, bool do_initial_step  ) {
        long    target_step;
        long    move;
        long    next_move;
        int     sign;
        
        sign          = -1;
        move          = initial_step;
        // int arg_delay, float arg_speed, float arg_acc, long arg_step 
        if ( do_initial_step ){
            doHrDanceStep( 0,    speed,         HR_STD_ACC, move       );
        }
        
        move          =  sign * ( initial_step * 2 );
        Serial.print( "vibrate_hr move  " );
        Serial.println(  move );
        
        doHrDanceStep( 0,    speed,         HR_STD_ACC, move       );
        
        for ( int ix  = 0;   ix <= 200;  ix ++ ) {   // change to do while true? or is this a safe out ??
             sign        *= -1;
             next_move    = sign * ( abs( move ) - delta_step );
             move         = next_move;
             Serial.print( "move  " );
             Serial.println(  move );
             doHrDanceStep( 0,    speed,         HR_STD_ACC, move       );
             //total        += move;
             // print( move, "       ", total )
             if ( abs( move ) < 1 ){
                 break;
             } 
        }
}

// ----------------------------------------------
// vibrate hand, in increasing amounts -- model in python 
// delta_step
// max_step
// speed
// _geo !! version 
void vibrate_hr_up( long delta_step, long max_step, long speed, long acc   ) {
        //long    target_step;
        long    move;
        long    next_move;
        int     sign;

       sign          = 1;
       move          =  sign * ( delta_step  );
       doHrDanceStep( 0,    speed,  acc, move       );

       for ( int ix  = 0;   ix <= 200;  ix ++ ) {

           sign        *= -1;
           next_move    = sign * ( abs( move ) + delta_step );
           
           move         = next_move;
           Serial.print( "vibrate_hr_up move  " );
           Serial.println(  move );
           doHrDanceStep( 0,    speed,  acc, move       );
           if ( abs( move ) > max_step ){
               break;
           }
       }
}
        
// ----------------------------------------------
// stagger starting 100 away from target 
//  sign = 1 if start from 100, sign = -1 if start form -100
void hr_stager_from_100( int sign  ) {
 
        sign    *= -1;
        doHrDanceStep( 500,  HR_STD_ACC, HR_STD_ACC,  sign * 30  );
        doHrDanceStep( 500,  HR_STD_ACC, HR_STD_ACC,  sign * 5   );
        doHrDanceStep( 2000, HR_STD_ACC, HR_STD_ACC,  sign * 25  );
        doHrDanceStep( 1000, HR_STD_ACC, HR_STD_ACC,  sign * 10  );
        doHrDanceStep( 500,  HR_STD_ACC, HR_STD_ACC,  sign * -5  );
        doHrDanceStep( 2000, HR_STD_ACC, HR_STD_ACC,  sign * 30  );
        doHrDanceStep( 500,  HR_STD_ACC, HR_STD_ACC,  sign * 10  );
        doHrDanceStep( 200,  HR_STD_ACC, HR_STD_ACC,  sign * -5  );
}
     
// ---------- begin subroutine ----------
// this is how you get multiple values for a command 
void getArgs( ) {
    // no check for overrun yet ever??
    long   val;
//    Serial.println( "starting getArgs" );
    cmd_args_max  = -1;   
    while ( true ) {
        //get next 
        if ( serialCmd.doneNext() )  {
            break;
        }
        val    = serialCmd.getNext( );
        cmd_args_max            += 1;
        cmd_args[cmd_args_max]   = val;
    }
    // echo back
//    for ( int ix  = 0;   ix <= cmd_args_max;  ix ++ ) {
//        Serial.println( cmd_args[ix] ); 
//    }
}

// ----------------------------------------------
// move with a speed and acc
void goToHrStep( long target_step, float arg_speed, float arg_acc   ) {
  
    STEPPER_HR.setMaxSpeed(     arg_speed );
    STEPPER_HR.setAcceleration( arg_acc );
    moveToHr( target_step );                     // void moveToHr
}

// ----------------------------------------------
// move with a speed and acc  tweaked
void goToMinStep( long target_step, float arg_speed, float arg_acc   ) {
  
    STEPPER_MIN.setMaxSpeed(     arg_speed );
    STEPPER_MIN.setAcceleration( arg_acc );
    moveToMin( target_step );
 
}

// ----------------------------------------------
// from args no delay 
void danceStep(    ) {
     if ( cmd_args[ 0 ] == HR_IX ){  
            //                arg_speed,      arg_acc,      delta_step  ) {   
            doHrDanceStep( 0, cmd_args[ 1 ],  cmd_args[ 2 ], cmd_args[ 3 ]  );     // 
      }
      else {
            doMinDanceStep(0, cmd_args[ 1 ],  cmd_args[ 2 ], cmd_args[ 3 ]  );     // 
      }
}

// ----------------------------------------------
// this is the move to absolute position
// tweaked move to plus run * tweaked 
void moveToMin( long pos ) {
    
    STEPPER_MIN.moveTo( pos + tweak_min  );
    STEPPER_MIN.enableOutputs( ); 
    while ( STEPPER_MIN.run() ) {
                // nothing to see here 
    }
    STEPPER_MIN.disableOutputs( );   
}

// ----------------------------------------------
// this is the move of the hr hand to an absolute position, not the hr the steps 
// tweaked move to plus run * tweaked 
void moveToHr( long pos ) {
    Serial.print(  "move to hr" ); 
    Serial.println(  pos + tweak_hr ); 
    
    STEPPER_HR.moveTo( pos + tweak_hr  );
    STEPPER_HR.enableOutputs( ); 
    while ( STEPPER_HR.run() ) {
                // nothing to see here 
    }
    STEPPER_HR.disableOutputs( );   
}

// ----------------------------------------------
// tet the minute step position 
// tweaked 
long getPosMin(   ) {
      return( STEPPER_MIN.currentPosition()  - tweak_min ) ;
}

// ----------------------------------------------
// tet the hr step position 
// tweaked 
long getPosHr(   ) {
      return( STEPPER_HR.currentPosition()  - tweak_hr ) ;
}

// ----------------------------------------------
// tweaked 
void zeroMin(   ) {
      STEPPER_MIN.setCurrentPosition( tweak_min );
}

// ----------------------------------------------
// tweaked 
void setPosMin( long a_step  ) {
      STEPPER_MIN.setCurrentPosition( tweak_min + a_step );
}
// ----------------------------------------------
// tweaked 
void setPosHr( long a_step  ) {
      STEPPER_HR.setCurrentPosition( tweak_hr + a_step );
}

// ----------------------------------------------
// tweaked  use setHr( 0 ) instead 
void zeroHr(   ) {
      STEPPER_HR.setCurrentPosition( tweak_hr );
}

// ----------------------------------------------
// ** tweaked 
// move delta_step is relative to current place so should always move 
void doHrDanceStep( int arg_delay, float arg_speed, float arg_acc, long delta_step  ) {
      long  target_step;
      
      delay( arg_delay );
      target_step     =  getPosHr() + delta_step;
      goToHrStep( target_step, arg_speed, arg_acc   );  
}

// ----------------------------------------------
// this is a relative move 
// ** tweaked 
void doMinDanceStep( int arg_delay, float arg_speed, float arg_acc, long delta_step  ) {
      delay( arg_delay );
      goToMinStep( getPosMin( ) + delta_step, arg_speed, arg_acc   );  
}


// ----------------------------------------------------------------
// lots of status info 
void statusReport( void ) {
    //    !!!!! needs update for hr and minute motors 
  
//    long     ret_long;
//    float    ret_float;
    
    Serial.println( F( "" ) );
    Serial.println( F( "Status  updated for 2 motors ??") );  
    Serial.println( VERSION_ID  );
   
    Serial.print( F( "Hr Position: ") ); 
    Serial.println(  STEPPER_HR.currentPosition() );  // !! change for tweaked 

    Serial.print( F( "Min Position: ") ); 
    Serial.println(  getPosMin( ) ); 

    Serial.print( F( "Hr tweak: ") ); 
    Serial.println(  tweak_hr ); 

    Serial.print( F( "Min tweak: ") ); 
    Serial.println(  tweak_min ); 
  
    Serial.print( F( "Hr MaxSpeed: ") ); 
    //ret_float = STEPPER_HR.maxSpeed ();          // float AccelStepper::maxSpeed ()     The most recently set max speed
    Serial.println(  STEPPER_HR.maxSpeed () ); 

    Serial.print( F( "Min MaxSpeed: ") ); 
    //ret_float = STEPPER_MIN.maxSpeed ();          // float AccelStepper::maxSpeed ()     The most recently set max speed
    Serial.println(  STEPPER_MIN.maxSpeed () ); 

    // Serial.println( F( "ann   setAcceleration" ) ); 
}

// ------------------------------------------------------
void rptVersion( )   {
    Serial.println( VERSION_ID  );
}

// ---------- begin setup ----------
void setup()   {
  
      Serial.begin( BAUD_RATE );
      
      serialCmd             = SerialCmd();
      serialCmd.resetCmd(  );
      // pinMode( IRPinOut, OUTPUT );  // must use z command to set up pin out 
      //pinMode( TIME_CHECK_PIN, OUTPUT );
      delay( 1000 );     // setup time, may or may not be needed 

      rptVersion();
      Serial.println( F( "ok"  ) );
}

// ======================= eof ==============================







